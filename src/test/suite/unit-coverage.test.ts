import * as assert from 'assert';
import * as vscode from 'vscode';

suite('Extension Test Suite', () => {
    test('Test extension activation and basic functionality', async () => {
        // Test extension presence and activation
        const extension = vscode.extensions.getExtension('sumitdev.promptious-optimizer');
        assert.ok(extension);

        if (extension) {
            await extension.activate();
            assert.ok(extension.isActive);
        }
    });

    test('Test all commands are registered', async () => {
        const commands = await vscode.commands.getCommands(true);
        const expectedCommands = [
            'promptious.optimizePrompt',
            'promptious.optimizeSelection',
            'promptious.openSettings'
        ];

        expectedCommands.forEach(command => {
            assert.ok(commands.includes(command), `Command ${command} should be registered`);
        });
    });

    test('Test configuration properties', () => {
        const config = vscode.workspace.getConfiguration('promptious');

        // Test all configuration properties exist and have correct types
        const apiKey = config.get('apiKey');
        const autoCopy = config.get('autoCopy');
        const showNotifications = config.get('showNotifications');
        const model = config.get('model');

        assert.strictEqual(typeof apiKey, 'string');
        assert.strictEqual(typeof autoCopy, 'boolean');
        assert.strictEqual(typeof showNotifications, 'boolean');
        assert.strictEqual(typeof model, 'string');
    });

    test('Test status bar item creation', () => {
        const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
        statusBarItem.text = "$(lightbulb) Promptious";
        statusBarItem.tooltip = "Click to optimize prompt";
        statusBarItem.command = 'promptious.optimizePrompt';
        statusBarItem.show();

        assert.ok(statusBarItem);
        assert.strictEqual(statusBarItem.text, "$(lightbulb) Promptious");
        assert.strictEqual(statusBarItem.tooltip, "Click to optimize prompt");
        assert.strictEqual(statusBarItem.command, 'promptious.optimizePrompt');

        statusBarItem.hide();
        statusBarItem.dispose();
    });

    test('Test document and editor operations', async () => {
        // Test document creation
        const doc = await vscode.workspace.openTextDocument({
            content: 'test prompt content',
            language: 'plaintext'
        });

        assert.ok(doc);
        assert.strictEqual(doc.getText(), 'test prompt content');
        assert.strictEqual(doc.languageId, 'plaintext');

        // Test editor operations
        const editor = await vscode.window.showTextDocument(doc);
        assert.ok(editor);

        // Test selection operations
        const selection = new vscode.Selection(0, 0, 0, 5);
        editor.selection = selection;
        assert.ok(editor.selection);
        assert.strictEqual(editor.selection.start.line, 0);
        assert.strictEqual(editor.selection.end.line, 0);
    });

    test('Test markdown document creation', async () => {
        const markdownContent = `# Prompt Optimization Results

**Generated:** ${new Date().toLocaleString()}  
**Improvement Score:** 80.0%

## Original Prompt
\`\`\`
test prompt
\`\`\`

## Optimized Prompt
\`\`\`
optimized test prompt
\`\`\`

## Applied Techniques
- **Zero-shot**: No examples provided
- **Few-shot**: Few examples provided

## Explanation
This is a test explanation for the optimization.

## Next Steps
1. Review the optimized prompt above
2. Test it with your AI model
3. Adjust if needed based on results

---
*Generated by Promptious Optimizer Extension*
`;

        const doc = await vscode.workspace.openTextDocument({
            content: markdownContent,
            language: 'markdown'
        });

        assert.ok(doc);
        assert.strictEqual(doc.languageId, 'markdown');
        assert.ok(doc.getText().includes('# Prompt Optimization Results'));
        assert.ok(doc.getText().includes('test prompt'));
        assert.ok(doc.getText().includes('80.0%'));
    });

    test('Test progress reporting', async () => {
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Testing progress...",
            cancellable: false
        }, async (progress) => {
            progress.report({ increment: 0, message: "Starting test..." });
            progress.report({ increment: 30, message: "Analyzing prompt..." });
            progress.report({ increment: 30, message: "Sending request to API..." });
            progress.report({ increment: 30, message: "Processing response..." });
            progress.report({ increment: 10, message: "Complete!" });
        });
    });

    test('Test clipboard operations', async () => {
        const testText = "Test clipboard content for prompt optimization";
        await vscode.env.clipboard.writeText(testText);

        const clipboardText = await vscode.env.clipboard.readText();
        assert.strictEqual(clipboardText, testText);
    });

    test('Test URI operations', () => {
        // Test file URI
        const fileUri = vscode.Uri.file('/test/path/to/file.txt');
        assert.ok(fileUri);
        assert.strictEqual(fileUri.fsPath, '/test/path/to/file.txt');
        assert.strictEqual(fileUri.scheme, 'file');
    });

    test('Test range and position operations', () => {
        // Test position
        const position = new vscode.Position(5, 10);
        assert.strictEqual(position.line, 5);
        assert.strictEqual(position.character, 10);

        // Test range
        const range = new vscode.Range(0, 0, 5, 10);
        assert.strictEqual(range.start.line, 0);
        assert.strictEqual(range.end.line, 5);
        assert.strictEqual(range.start.character, 0);
        assert.strictEqual(range.end.character, 10);

        // Test selection
        const selection = new vscode.Selection(0, 0, 5, 10);
        assert.ok(selection);
        assert.strictEqual(selection.start.line, 0);
        assert.strictEqual(selection.end.line, 5);
    });

    test('Test workspace operations', () => {
        // Test workspace folders
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (workspaceFolders) {
            assert.ok(Array.isArray(workspaceFolders));
        } else {
            assert.strictEqual(workspaceFolders, undefined);
        }

        // Test workspace name
        const workspaceName = vscode.workspace.name;
        assert.ok(typeof workspaceName === 'string' || workspaceName === undefined);
    });

    test('Test extension context operations', () => {
        const extension = vscode.extensions.getExtension('sumitdev.promptious-optimizer');
        if (extension) {
            assert.ok(extension.id);
            assert.ok(extension.extensionPath);
            assert.ok(extension.packageJSON);
            assert.ok(extension.isActive);
        }
    });

    test('Test input validation logic', () => {
        // Test the validation logic that would be used in the extension
        const validatePrompt = (value: string) => {
            if (!value || value.trim().length < 3) {
                return 'Prompt must be at least 3 characters long';
            }
            if (value.length > 10000) {
                return 'Prompt must be less than 10000 characters';
            }
            return null;
        };

        // Test various validation scenarios
        assert.strictEqual(validatePrompt(''), 'Prompt must be at least 3 characters long');
        assert.strictEqual(validatePrompt('ab'), 'Prompt must be at least 3 characters long');
        assert.strictEqual(validatePrompt('   '), 'Prompt must be at least 3 characters long');
        assert.strictEqual(validatePrompt('a'.repeat(10001)), 'Prompt must be less than 10000 characters');
        assert.strictEqual(validatePrompt('valid prompt'), null);
        assert.strictEqual(validatePrompt('This is a valid prompt for testing'), null);
    });

    test('Test error handling scenarios', () => {
        // Test error message generation logic
        const generateErrorMessage = (error: any) => {
            let errorMessage = 'Failed to optimize prompt. ';

            if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
                errorMessage += 'Request timed out. Please check your internet connection and try again.';
            } else if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
                errorMessage += 'Cannot connect to the server. Please check the backend URL in settings.';
            } else if (error.response?.status === 401) {
                errorMessage += 'Authentication failed. Please check your API key.';
            } else if (error.response?.status === 429) {
                errorMessage += 'Rate limit exceeded. Please try again later.';
            } else if (error.response?.data?.error) {
                errorMessage += error.response.data.error;
            } else if (error.message) {
                errorMessage += error.message;
            } else {
                errorMessage += 'Please check your configuration and try again.';
            }

            return errorMessage;
        };

        // Test different error scenarios
        assert.ok(generateErrorMessage({ code: 'ECONNABORTED' }).includes('Request timed out'));
        assert.ok(generateErrorMessage({ code: 'ECONNREFUSED' }).includes('Cannot connect to the server'));
        assert.ok(generateErrorMessage({ response: { status: 401 } }).includes('Authentication failed'));
        assert.ok(generateErrorMessage({ response: { status: 429 } }).includes('Rate limit exceeded'));
        assert.ok(generateErrorMessage({ response: { data: { error: 'API error' } } }).includes('API error'));
        assert.ok(generateErrorMessage({ message: 'Network error' }).includes('Network error'));
        assert.ok(generateErrorMessage({}).includes('Please check your configuration'));
    });

    test('Test markdown generation logic', () => {
        // Test the markdown generation logic
        const generateResultsMarkdown = (original: string, response: any) => {
            const timestamp = new Date().toLocaleString();
            const score = response.improvement_score ? (response.improvement_score * 100).toFixed(1) : 'N/A';

            return `# Prompt Optimization Results

**Generated:** ${timestamp}  
**Improvement Score:** ${score}%

## Original Prompt
\`\`\`
${original}
\`\`\`

## Optimized Prompt
\`\`\`
${response.optimized_prompt}
\`\`\`

## Applied Techniques
${response.applied_techniques?.map((tech: any) => `- **${tech.name}**: ${tech.description}`).join('\n') || 'No techniques specified'}

## Explanation
${response.explanation || 'No explanation provided'}

## Next Steps
1. Review the optimized prompt above
2. Test it with your AI model
3. Adjust if needed based on results
4. Learn more about prompt engineering

---
*Generated by Promptious Optimizer Extension*
`;
        };

        const mockResponse = {
            optimized_prompt: 'optimized test prompt',
            improvement_score: 0.8,
            applied_techniques: [
                { name: 'Zero-shot', description: 'No examples provided' },
                { name: 'Few-shot', description: 'Few examples provided' }
            ],
            explanation: 'This is a test explanation'
        };

        const markdown = generateResultsMarkdown('test prompt', mockResponse);

        assert.ok(markdown.includes('# Prompt Optimization Results'));
        assert.ok(markdown.includes('test prompt'));
        assert.ok(markdown.includes('optimized test prompt'));
        assert.ok(markdown.includes('80.0%'));
        assert.ok(markdown.includes('Zero-shot'));
        assert.ok(markdown.includes('Few-shot'));
        assert.ok(markdown.includes('This is a test explanation'));
    });

    test('Test history management logic', () => {
        // Test history size limit logic
        const MAX_HISTORY_SIZE = 100;
        const history: any[] = [];

        // Simulate adding items to history
        for (let i = 0; i < 105; i++) {
            history.push({
                original: `prompt ${i}`,
                optimized: `optimized prompt ${i}`,
                techniques: ['zero_shot'],
                timestamp: new Date(),
                score: 0.8
            });

            // Maintain history size limit
            if (history.length > MAX_HISTORY_SIZE) {
                history.shift(); // Remove oldest entry
            }
        }

        assert.strictEqual(history.length, MAX_HISTORY_SIZE);
        assert.strictEqual(history[0].original, 'prompt 5'); // First 5 items should be removed
        assert.strictEqual(history[history.length - 1].original, 'prompt 104'); // Last item should be the newest
    });

    test('Test all code branches and edge cases', () => {
        // Test different configuration scenarios
        const config = vscode.workspace.getConfiguration('promptious');

        // Test with different API key scenarios
        const apiKey = config.get('apiKey');
        if (!apiKey) {
            // Test branch for missing API key
            assert.strictEqual(apiKey, '');
        } else {
            // Test branch for configured API key
            assert.ok(typeof apiKey === 'string');
        }

        // Test with different auto-copy settings
        const autoCopy = config.get('autoCopy');
        if (autoCopy) {
            // Test branch for auto-copy enabled
            assert.strictEqual(autoCopy, true);
        } else {
            // Test branch for auto-copy disabled
            assert.strictEqual(autoCopy, true);
        }

        // Test with different notification settings
        const showNotifications = config.get('showNotifications');
        if (showNotifications) {
            // Test branch for notifications enabled
            assert.strictEqual(showNotifications, true);
        } else {
            // Test branch for notifications disabled
            assert.strictEqual(showNotifications, true);
        }

        // Test with different model settings
        const model = config.get('model');
        if (model) {
            // Test branch for configured model
            assert.ok(typeof model === 'string');
        }
    });
});
